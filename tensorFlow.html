<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pose Detection</title>
    <style>
      #imageContainer {
        margin-top: 20px;
        position: relative;
      }
      #previewImage {
        max-width: 100%;
        max-height: 500px;
      }
      #canvas {
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <input type="file" id="imageInput" accept="image/*" />
    <div id="imageContainer">
      <img id="previewImage" src="" alt="Preview" style="display: none" />
      <canvas id="canvas"></canvas>
    </div>

    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <!-- Load Pose Detection -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <script>
      let detector;
      let canvas;
      let ctx;

      async function initPoseDetection() {
        const model = poseDetection.SupportedModels.MoveNet;
        const detectorConfig = {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
        };
        detector = await poseDetection.createDetector(model, detectorConfig);
      }

      async function detectPose(image) {
        const poses = await detector.estimatePoses(image);
        return poses;
      }

      function drawPose(poses) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (const pose of poses) {
          // Draw keypoints
          for (const keypoint of pose.keypoints) {
            if (keypoint.score > 0.3) {
              ctx.beginPath();
              ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
              ctx.fillStyle = "red";
              ctx.fill();
            }
          }

          // Draw connections
          const connections = pose.keypoints.reduce((acc, keypoint, i) => {
            if (keypoint.score > 0.3) {
              acc.push(i);
            }
            return acc;
          }, []);

          for (let i = 0; i < connections.length - 1; i++) {
            const start = pose.keypoints[connections[i]];
            const end = pose.keypoints[connections[i + 1]];
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.strokeStyle = "blue";
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        }
      }

      window.onload = async function () {
        await initPoseDetection();

        const imageInput = document.getElementById("imageInput");
        const previewImage = document.getElementById("previewImage");
        canvas = document.getElementById("canvas");
        ctx = canvas.getContext("2d");

        imageInput.addEventListener("change", async (event) => {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();

            reader.onload = async (e) => {
              previewImage.src = e.target.result;
              previewImage.style.display = "block";

              // Wait for image to load
              previewImage.onload = async () => {
                // Set canvas size to match image
                canvas.width = previewImage.width;
                canvas.height = previewImage.height;

                // Detect poses
                const poses = await detectPose(previewImage);
                drawPose(poses);
              };
            };

            reader.readAsDataURL(file);
          }
        });
      };
    </script>
  </body>
</html>
